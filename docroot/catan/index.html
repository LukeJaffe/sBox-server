<html>
<body>

<meta http-equiv='cache-control' content='no-cache'>
<meta http-equiv='expires' content='0'>
<meta http-equiv='pragma' content='no-cache'>

<style>
.my_canvas {
    background: #eee; 
    width: 700px; 
    height: 700px; 
    border: 1px #ccc solid;
}
</style>


<canvas id="board" class="my_canvas" width='700px' height='700px'></canvas> 

<div hidden>
    <img src="forest.jpg" id = "forest" alt="NO IMG" height="42" width="42">
    <img src="wheat.jpg" id = "wheat" alt="NO IMG" height="42" width="42">
    <img src="pasture.jpg" id = "pasture" alt="NO IMG" height="42" width="42">
    <img src="ore.jpg" id = "ore" alt="NO IMG" height="42" width="42">
    <img src="brick.jpg" id = "brick" alt="NO IMG" height="42" width="42">
    <img src="desert.jpg" id = "desert" alt="NO IMG" height="42" width="42">
</div>

<script type="text/javascript">

function feq(a, b) 
{
    if (Math.abs(a-b) < 1e-5)
        return true;
    else
        return false;
}

var canvas, context;


// get a reference to the board, and the drawing context
canvas  = document.getElementById('board');
if ( canvas && canvas.getContext ) 
{
    context = canvas.getContext('2d');

} 
else 
{
    // unsupported browser?
    alert("Couldn't get a reference to the HTML 5 canvas."
      + "\nYour browser doesn't appear to support this page.");
}

function clearCanvas( context, canvas ) 
{
    context.clearRect( 0, 0, canvas.width, canvas.height );
}

/* Event stuff */
function addEvent( obj, type, fn ) {

  if ( obj.attachEvent ) {

    obj['e'+type+fn] = fn;

    obj[type+fn] = function(){obj['e'+type+fn]( window.event );}

    obj.attachEvent( 'on'+type, obj[type+fn] );

  } else

    obj.addEventListener( type, fn, false );

}


/* HexType class with solid color background*/
function HexType(resource, roll)
{
    this.resource = resource
    this.roll = roll
    if (this.resource == 'wood')
    {
        this.color = '#663300';
        this.texture = document.getElementById("forest");
    }
    else if (this.resource == 'wheat')
    {
        this.color = '#FFFF00';
        this.texture = document.getElementById("wheat");
    }
    else if (this.resource == 'pasture')
    {
        this.color = '#00FF00';
        this.texture = document.getElementById("pasture");
    }    
    else if (this.resource == 'ore')
    { 
        this.color = '#666666';
        this.texture = document.getElementById("ore");
    }
    else if (this.resource == 'brick')
    { 
        this.color = '#FF0000';
        this.texture = document.getElementById("brick");
    }
    else if (this.resource == 'desert')
    { 
        this.color = '#967117';
        this.texture = document.getElementById("desert");
    }
}


/* Hex class */
function Hex(x, y, r, t)
{
    /* Store inputs */
    this.x = x;
    this.y = y;
    this.r = r;
    this.t = t;
    this.s = false;
    this.robber = false;

    /* Calculate and store vertices */
    a = (Math.sqrt(3)/2)*r;
    b = r/2;
    v = [];
    v.push([x+r, y]);
    v.push([x+b, y-a]);
    v.push([x-b, y-a]);
    v.push([x-r, y]);
    v.push([x-b, y+a]);
    v.push([x+b, y+a]);
    v.push([x+r, y]);
    this.v = v

    /* Get roads */
    this.roads = [];
    for (var i = 0; i < v.length-1; i++)
        this.roads.push([v[i][0], v[i][1], v[i+1][0], v[i+1][1]]);

    /* Get vertices */
    this.verts = [];
    for (var i = 0; i < v.length-1; i++)
        this.verts.push(v[i])
}


function clippedBackgroundImage( context, img, w, h )
{
    context.save(); // Save the context before clipping
    context.clip(); // Clip to whatever path is on the context

    var imgHeight = w / img.width * img.height;
    if (imgHeight < h){
    context.fillStyle = '#000';
    context.fill();
    }
    context.drawImage(img,-w,-h,2*w,2*imgHeight);

    context.restore(); // Get rid of the clipping region
}


Hex.prototype.draw = function()
{
    /* Draw textures on hexes */
    context.save(); // Save the context before we muck up its properties
    context.translate(this.x,this.y);

    context.beginPath();
    context.moveTo(this.v[0][0] - this.x, this.v[0][1] - this.y);
    for (var i = 1; i < this.v.length; i++)
    {
        x = this.v[i][0] - this.x;
        y = this.v[i][1] - this.y;
        context.lineTo(x,y);
    }
    context.closePath();

    clippedBackgroundImage( context, this.t.texture, this.r, this.r );
    context.strokeStyle = '#000000';
    context.stroke();  // Now draw our path
    context.restore(); // Put the canvas back how it was before we started

    /* Draw roll circles */
    context.beginPath();
    context.arc(this.x, this.y, this.r/3, 0, 2*Math.PI);
    context.fillStyle = '#FFE4BC';
    context.fill();
    context.strokeStyle = '#000000';
    context.stroke();

    /* Draw roll numbers */
    context.font = "30px Arial";
    if (this.t.roll < 10)
        xoff = this.r/10;
    else
        xoff = this.r/5
    context.fillStyle = '#000000';
    context.fillText(this.t.roll.toString(), this.x-xoff, this.y+r/10);
}

Hex.prototype.draw_roll = function()
{
    /* Draw roll circles */
    context.beginPath();
    context.arc(this.x, this.y, this.r/3, 0, 2*Math.PI);
    context.fillStyle = '#FFE4BC';
    context.fill();
    context.strokeStyle = '#000000';
    context.stroke();

    /* Draw roll numbers */
    context.font = "30px Arial";
    if (this.t.roll < 10)
        xoff = this.r/10;
    else
        xoff = this.r/5
    context.fillStyle = '#000000';
    context.fillText(this.t.roll.toString(), this.x-xoff, this.y+r/10);
}

Hex.prototype.collision = function(x, y)
{
    dx = this.x - x;
    dy = this.y - y;
    dist = Math.sqrt((dx*dx) + (dy*dy));
    if (dist > (Math.sqrt(3)/2)*this.r)
        return false;
    else
        return true;
}

Hex.prototype.select = function()
{
    //this.s = true;
    /* Draw roll circles */
    context.beginPath();
    context.arc(this.x, this.y, (Math.sqrt(3)/2)*this.r, 0, 2*Math.PI);
    context.strokeStyle = '#FFFF00';
    context.stroke();
}

Hex.prototype.deselect = function()
{
    /*
    if (this.s == true)
    {
        this.s = false;
        this.draw();
    }
    */
    state_image = new Image();
    state_image.src = default_state;
    state_image.onload = function() { context.drawImage(state_image, 0, 0); }
}

Hex.prototype.click = function()
{
    /* Draw the robber */
    context.beginPath();
    context.arc(this.x, this.y, this.r/3, 0, 2*Math.PI);
    context.fillStyle = '#000000';
    context.fill();

    /* Redraw roll over old robber */
    hexes[robber_hex].draw_roll();
    hexes[robber_hex].robber = false;
    this.robber = true;

    /* Save the default canvas appearance */
    default_state = canvas.toDataURL();
}

function Road(v, r)
{
    this.v1 = [v[0], v[1]];
    this.v2 = [v[2], v[3]];
    this.x = (v[0]+v[2])/2;
    this.y = (v[1]+v[3])/2;
    this.r = r;
    this.built = false;
    this.owner = "none";
    this.a = [];
}

Road.prototype.adjacent = function(road)
{
    if (
        (feq(this.v1[0], road.v1[0]) && feq(this.v1[1], road.v1[1])) ||
        (feq(this.v1[0], road.v2[0]) && feq(this.v1[1], road.v2[1])) ||
        (feq(this.v2[0], road.v1[0]) && feq(this.v2[1], road.v1[1])) ||
        (feq(this.v2[0], road.v2[0]) && feq(this.v2[1], road.v2[1]))
    )
        return true;
    else
        return false;
}

Road.prototype.add_adjacent = function(idx)
{
    this.a.push(idx);
}

Road.prototype.collision = function(x, y)
{
    dx = this.x - x;
    dy = this.y - y;
    dist = Math.sqrt((dx*dx) + (dy*dy));
    if (dist > this.r/3)
        return false;
    else
        return true;
}

Road.prototype.select = function()
{
    context.beginPath();
    context.arc(this.x, this.y, this.r/3, 0, 2*Math.PI);
    context.strokeStyle = '#FF0000';
    context.stroke();
}

Road.prototype.deselect = function()
{

}

Road.prototype.click = function()
{

}

function Town(v, r)
{
    this.v = v;
    this.x = v[0];
    this.y = v[1];
    this.r = r;
    this.built = false;
    this.owner = "none";
    this.adj_roads = [];
}

Town.prototype.adj_road = function(road)
{
    if (
        (feq(this.v[0], road.v1[0]) && feq(this.v[1], road.v1[1])) ||
        (feq(this.v[0], road.v2[0]) && feq(this.v[1], road.v2[1]))
    )
        return true;
    else
        return false;
}

Town.prototype.add_adj_road = function(idx)
{
    this.adj_roads.push(idx);
}

Town.prototype.collision = function(x, y)
{
    dx = this.x - x;
    dy = this.y - y;
    dist = Math.sqrt((dx*dx) + (dy*dy));
    if (dist > this.r/4)
        return false;
    else
        return true;
}

Town.prototype.select = function()
{
    context.beginPath();
    context.arc(this.x, this.y, this.r/4, 0, 2*Math.PI);
    context.strokeStyle = '#0000FF';
    context.stroke();
}

Town.prototype.click = function()
{
    console.log("Town clicked!");
    console.log(this.adj_roads.length);
    if (this.adj_roads.length == 2)
    {
    }
    else if (this.adj_roads.length == 3)
    {
        /* Get vertices adjacent to town */
        verts = [];
        for (var i = 0; i < this.adj_roads.length; i++)
            verts.push([roads[this.adj_roads[i]].x, roads[this.adj_roads[i]].y]);

        console.log(verts);

        /* Draw triangle for town */
        context.beginPath();
        context.moveTo(verts[0][0], verts[0][1]);
        for (var i = 1; i < verts.length; i++)
        {
            context.lineTo(verts[i][0], verts[i][1]);
        }
        context.lineTo(verts[0][0], verts[0][1]);
        context.closePath();
        context.fillStyle = '#0000FF';
        context.fill();  // Now draw our path
    }

    /* Save the default canvas appearance */
    default_state = canvas.toDataURL();
}

function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}

function roads_equal(a, b) 
{
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;

    // If you don't care about the order of the elements inside
    // the array, you should sort both arrays here.

    c1 = true;
    for (var i = 0; i < a.length; ++i) 
        if (!feq(a[i], b[i])) c1 = false;
    c2 = true;
    var c = [b[2],b[3],b[0],b[1]];
    for (var i = 0; i < a.length; ++i) 
        if (!feq(a[i], c[i])) c2 = false;
    return c1 || c2;
}

Array.prototype.unique_roads = function() 
{
    var a = this.concat();
    for (var i = 0; i < a.length; ++i) 
        for (var j = i+1; j < a.length; ++j) 
            if (roads_equal(a[i], a[j]))
                a.splice(j--, 1);

    return a;
};

function verts_equal(a, b) 
{
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;

    // If you don't care about the order of the elements inside
    // the array, you should sort both arrays here.

    for (var i = 0; i < a.length; ++i) 
        if (!feq(a[i], b[i])) return false;
    return true;
}

Array.prototype.unique_verts = function() 
{
    var a = this.concat();
    for (var i = 0; i < a.length; ++i) 
        for (var j = i+1; j < a.length; ++j) 
            if (verts_equal(a[i], a[j]))
                a.splice(j--, 1);

    return a;
};

/* Global variables */
hexes = [], roads = [], towns = [];
default_state = 0;
robber_hex = 0;

function setup()
{
    x0 = 350;
    y0 = 350;
    r = 75;

    a = r*0.5;
    b = r*Math.sqrt(3)/2;

    num_hexes = 19;

    resources = ['wood', 'wood', 'wood', 'wood',
                'wheat', 'wheat', 'wheat', 'wheat',
                'pasture', 'pasture', 'pasture', 'pasture',
                'ore', 'ore', 'ore',
                'brick', 'brick', 'brick',
                'desert'];

    rolls = [2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 8, 9, 9, 10, 10, 11, 11, 12];

    origins = [ 
                [0, 0],
                [0, 2*b], [1.5*r, b], [1.5*r, -b],        //First circle
                [0, -2*b], [-1.5*r, -b], [-1.5*r, b],     //First circle
                [0, 4*b], [3*r, 2*b], [3*r, -2*b],        //Second circle p1
                [0, -4*b], [-3*r, -2*b], [-3*r, 2*b],     //Second circle p1
                [3*r, 0], [1.5*r, 3*b], [1.5*r, -3*b],    //Second circle p2
                [-3*r, 0], [-1.5*r, -3*b], [-1.5*r, 3*b]  //Second circle p2
              ]

    /* Shuffle indeces */
    resource_indices = [];
    roll_indices = [];
    for (var i = 0; i < num_hexes; i++)
    {
        resource_indices.push(i);
        if (i == num_hexes-1) break; 
        roll_indices.push(i);
    }
    shuffle(resource_indices);
    shuffle(roll_indices);

    roll_idx = 0;
    for (var i = 0; i < num_hexes; i++)
    {
        /* Get random indices */
        idx1 = resource_indices[i];
        idx2 = roll_indices[roll_idx];

        /* Create all needed hexes */
        if (resources[idx1] == 'desert')
            hexes.push(new Hex(x0+origins[i][0], y0+origins[i][1], r, 
                new HexType('desert', 7)));
        else    
        {
            hexes.push(new Hex(x0+origins[i][0], y0+origins[i][1], r, 
                new HexType(resources[idx1], rolls[idx2])));
            roll_idx += 1;
        }
    } 

    /* Get all road vertices */
    road_verts = [];
    for (var i = 0; i < hexes.length; i++)
        road_verts = road_verts.concat(hexes[i].roads); 
    road_verts = road_verts.unique_roads();

    /* Create road objects */
    for (var i = 0; i < road_verts.length; i++)
        roads.push(new Road(road_verts[i], r));

    /* Determine road adjacency */
    for (var i = 0; i < roads.length; i++)
        for (var j = 0; j < roads.length; j++)
            if (roads[i].adjacent(roads[j]) && i !== j)
                roads[i].add_adjacent(j);

    /* Get all vertices (for settlements/cities) */
    town_verts = [];
    for (var i = 0; i < hexes.length; i++)
        town_verts = town_verts.concat(hexes[i].verts);  
    town_verts = town_verts.unique_verts();

    /* Create town objects */
    for (var i = 0; i < town_verts.length; i++)
        towns.push(new Town(town_verts[i], r));

    /* Determine town->road adjacency */
    for (var i = 0; i < towns.length; i++)
        for (var j = 0; j < roads.length; j++)
            if (towns[i].adj_road(roads[j]) && i !== j)
                towns[i].add_adj_road(j);

    t = [0,0,0,0,0,0,0,0];
    for (var i = 0; i < towns.length; i++)
    {
        idx = towns[i].adj_roads.length;
        t[idx] += 1;
    }
    console.log(t);

    /* Draw water for background */
    context.fillStyle = '#ADD8E6';
    context.rect(0, 0, 700, 700);
    context.fill();

    /* Draw all hexes */
    for (var i = 0; i < hexes.length; i++)
        hexes[i].draw();

    /* Save the default canvas appearance */
    default_state = canvas.toDataURL();
}

addEvent(canvas, 'mousemove', function(e) 
{
    var posx = 0;
    var posy = 0;
    if (!e) var e = window.event;
    if (e.pageX || e.pageY)     {
        posx = e.pageX;
        posy = e.pageY;
    }
    else if (e.clientX || e.clientY)    {
        posx = e.clientX + document.body.scrollLeft
            + document.documentElement.scrollLeft;
        posy = e.clientY + document.body.scrollTop
            + document.documentElement.scrollTop;
    }

    /* Check posx and posy against hexes using concentric circles */
    state_image = new Image();
    state_image.src = default_state;
    context.drawImage(state_image, 0, 0);
    for (var i = 0; i < hexes.length; i++)
    {
        if (hexes[i].collision(posx, posy))
            hexes[i].select();
        //else
        //    hexes[i].deselect();
    }

    /* Check posx and posy against roads using concentric circles */
    for (var i = 0; i < roads.length; i++)
    {
        if (roads[i].collision(posx, posy))
            roads[i].select();
        //else
        //    roads[i].deselect();
    }

    /* Check posx and posy against towns using concentric circles */
    for (var i = 0; i < towns.length; i++)
    {
        if (towns[i].collision(posx, posy))
            towns[i].select();
        //else
        //    towns[i].deselect();
    }
});

addEvent(canvas, 'click', function(e) 
{
    var posx = 0;
    var posy = 0;
    if (!e) var e = window.event;
    if (e.pageX || e.pageY)     {
        posx = e.pageX;
        posy = e.pageY;
    }
    else if (e.clientX || e.clientY)    {
        posx = e.clientX + document.body.scrollLeft
            + document.documentElement.scrollLeft;
        posy = e.clientY + document.body.scrollTop
            + document.documentElement.scrollTop;
    }

    /* Check posx and posy against hexes using concentric circles */
    state_image = new Image();
    state_image.src = default_state;
    context.drawImage(state_image, 0, 0);
    for (var i = 0; i < hexes.length; i++)
    {
        if (hexes[i].collision(posx, posy) && robber_hex !== i)
        {
            hexes[i].click();
            robber_hex = i;
        }
    }

    /* Check posx and posy against roads using concentric circles */
    for (var i = 0; i < roads.length; i++)
    {
        if (roads[i].collision(posx, posy))
            roads[i].click();
    }

    /* Check posx and posy against towns using concentric circles */
    for (var i = 0; i < towns.length; i++)
    {
        if (towns[i].collision(posx, posy))
            towns[i].click();
    }
});

setup();

</script> 

</body>
</html>
